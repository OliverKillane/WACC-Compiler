use atoi::FromRadix10SignedChecked;

use std::{
    cmp::max,
    collections::{HashMap, LinkedList},
    intrinsics::{wrapping_add, wrapping_mul, wrapping_sub},
    iter::zip,
    mem::swap,
};

use crate::intermediate::*;

/// Represents a general value in a program.
#[derive(Clone, Copy)]
enum Var {
    DWord(i32),
    Word(i16),
    Byte(i8),
    Bool(bool),
    Ptr(DataRef),
}

/// Exit status of the program elements.
#[derive(Debug)]
enum ExitStatus {
    /// A code generated by an exit statement.
    Code(i32),
    /// A fault during program execution.
    Fault(String),
}

/// The state of the entire program.
struct ProgramState {
    /// All the variables in the current statement graph.
    vars: HashMap<VarRepr, Var>,
    /// The state of the memory with all the allocations.
    memory: HashMap<DataRef, Var>,
    /// Standard input
    stdin_data: Vec<u8>,
    /// The cursor of the standard input.
    stdin_ptr: usize,
    /// The standard output.
    stdout: String,
    /// Address of the highest allocation. Used for the malloc system.
    malloc_addr: DataRef,
}

/// Evaluates a pointer expression.
fn eval_ptrexpr(
    expr: &PtrExpr,
    functions: &HashMap<String, Function>,
    state: &mut ProgramState,
) -> Result<DataRef, ExitStatus> {
    Ok(match expr {
        PtrExpr::Null => 0,
        PtrExpr::DataRef(ptr) => *ptr + 1,
        PtrExpr::Var(var) => {
            if let Var::Ptr(ptr) = get_var(var, &mut state.vars) {
                *ptr
            } else {
                panic!("Mismatched variable type")
            }
        }
        PtrExpr::Deref(box ptr_expr) => {
            if let Var::Ptr(ptr) = deref_memory(ptr_expr, functions, state)? {
                *ptr
            } else {
                return Err(ExitStatus::Fault("Allocation type fault".to_string()));
            }
        }
        PtrExpr::Offset(ptr_expr, num_expr) => {
            let addr = eval_ptrexpr(ptr_expr, functions, state)?;
            let (num, size) = eval_numexpr(num_expr, functions, state)?;
            if size != NumSize::DWord {
                panic!("Mismatched pointer offset type");
            }
            (addr as i64 + num as i64) as u64
        }
        PtrExpr::Malloc(exprs) => {
            let vals = exprs
                .iter()
                .map(|expr| eval_expr(expr, functions, state))
                .collect::<Result<LinkedList<_>, _>>()?;
            let alloc_addr = state.malloc_addr;
            for val in vals {
                state.memory.insert(state.malloc_addr, val);
                state.malloc_addr += match val {
                    Var::DWord(_) => 4,
                    Var::Word(_) => 2,
                    Var::Byte(_) => 1,
                    Var::Bool(_) => 1,
                    Var::Ptr(_) => 8,
                }
            }
            alloc_addr
        }
        PtrExpr::WideMalloc(exprs) => {
            let vals = exprs
                .iter()
                .map(|expr| eval_expr(expr, functions, state))
                .collect::<Result<LinkedList<_>, _>>()?;
            let alloc_addr = state.malloc_addr;
            for val in vals {
                state.memory.insert(state.malloc_addr, val);
                state.malloc_addr += 8;
            }
            alloc_addr
        }
        PtrExpr::Call(name, args) => {
            if let Var::Ptr(ptr) = run_function(
                name,
                &args
                    .iter()
                    .map(|expr| eval_expr(expr, functions, state))
                    .collect::<Result<Vec<Var>, _>>()?,
                functions,
                state,
            )? {
                ptr
            } else {
                panic!("Invalid function return type")
            }
        }
    })
}

/// Evaluates a boolean expression.
fn eval_boolexpr(
    expr: &BoolExpr,
    functions: &HashMap<String, Function>,
    state: &mut ProgramState,
) -> Result<bool, ExitStatus> {
    Ok(match expr {
        BoolExpr::Const(bool) => *bool,
        BoolExpr::Var(var) => {
            if let Var::Bool(bool) = get_var(var, &mut state.vars) {
                *bool
            } else {
                panic!("Mismatched variable type")
            }
        }
        BoolExpr::Deref(ptr_expr) => {
            if let Var::Bool(bool) = deref_memory(ptr_expr, functions, state)? {
                *bool
            } else {
                return Err(ExitStatus::Fault("Allocation type fault".to_string()));
            }
        }
        BoolExpr::TestZero(num_expr) => {
            let (num, _) = eval_numexpr(num_expr, functions, state)?;
            num == 0
        }
        BoolExpr::TestPositive(num_expr) => {
            let (num, _) = eval_numexpr(num_expr, functions, state)?;
            num > 0
        }
        BoolExpr::PtrEq(ptr_expr1, ptr_expr2) => {
            eval_ptrexpr(ptr_expr1, functions, state)? == eval_ptrexpr(ptr_expr2, functions, state)?
        }
        BoolExpr::BoolOp(box bool_expr1, op, box bool_expr2) => {
            let bool1 = eval_boolexpr(bool_expr1, functions, state)?;
            let bool2 = eval_boolexpr(bool_expr2, functions, state)?;
            match op {
                BoolOp::And => bool1 && bool2,
                BoolOp::Or => bool1 || bool2,
                BoolOp::Xor => bool1 ^ bool2,
            }
        }
        BoolExpr::Not(box bool_expr) => !eval_boolexpr(bool_expr, functions, state)?,
        BoolExpr::Call(name, args) => {
            if let Var::Bool(bool) = run_function(
                name,
                &args
                    .iter()
                    .map(|expr| eval_expr(expr, functions, state))
                    .collect::<Result<Vec<Var>, _>>()?,
                functions,
                state,
            )? {
                bool
            } else {
                panic!("Invalid function return type")
            }
        }
    })
}

/// Evaluates a numeric expression.
fn eval_numexpr(
    expr: &NumExpr,
    functions: &HashMap<String, Function>,
    state: &mut ProgramState,
) -> Result<(i32, NumSize), ExitStatus> {
    Ok(match expr {
        NumExpr::Const(size, num) => (*num, *size),
        NumExpr::Var(var) => {
            let var = get_var(var, &mut state.vars);
            match var {
                Var::DWord(ref num) => (*num, NumSize::DWord),
                Var::Word(ref num) => (*num as i32, NumSize::Word),
                Var::Byte(ref num) => (*num as i32, NumSize::Byte),
                _ => panic!("Mismatched variable type"),
            }
        }
        NumExpr::Deref(size, ptr_expr) => {
            let var = deref_memory(ptr_expr, functions, state)?;
            match (var, size) {
                (Var::DWord(ref num), NumSize::DWord) => (*num, NumSize::DWord),
                (Var::Word(ref num), NumSize::Word) => (*num as i32, NumSize::Word),
                (Var::Byte(ref num), NumSize::Byte) => (*num as i32, NumSize::Byte),
                _ => return Err(ExitStatus::Fault("Allocation type fault".to_string())),
            }
        }
        NumExpr::ArithOp(box num_expr1, op, box num_expr2) => {
            let (num1, size1) = eval_numexpr(num_expr1, functions, state)?;
            let (num2, size2) = eval_numexpr(num_expr2, functions, state)?;
            if size1 != size2 {
                panic!("Mismatched sizes of arithmetic operation sides");
            }
            (
                match op {
                    ArithOp::Add => wrapping_add(num1, num2),
                    ArithOp::Sub => wrapping_sub(num1, num2),
                    ArithOp::Mul => wrapping_mul(num1, num2),
                    ArithOp::Div => num1 / num2,
                    ArithOp::Mod => num1 % num2,
                },
                size1,
            )
        }
        NumExpr::Cast(size, box num_expr) => {
            let (num, _) = eval_numexpr(num_expr, functions, state)?;
            (num, *size)
        }
        NumExpr::Call(name, args) => match run_function(
            name,
            &args
                .iter()
                .map(|expr| eval_expr(expr, functions, state))
                .collect::<Result<Vec<Var>, _>>()?,
            functions,
            state,
        )? {
            Var::DWord(num) => (num, NumSize::DWord),
            Var::Word(num) => (num as i32, NumSize::Word),
            Var::Byte(num) => (num as i32, NumSize::Byte),
            _ => panic!("Invalid function return type"),
        },
        NumExpr::SizeOf(var_type) => (
            match var_type {
                Type::Num(NumSize::DWord) => 4,
                Type::Num(NumSize::Word) => 2,
                Type::Num(NumSize::Byte) => 1,
                Type::Bool => 1,
                Type::Ptr => 8,
            },
            NumSize::DWord,
        ),
        NumExpr::SizeOfWideAlloc => (8, NumSize::DWord),
    })
}

/// Evaluates a general expression.
fn eval_expr(
    expr: &Expr,
    functions: &HashMap<String, Function>,
    state: &mut ProgramState,
) -> Result<Var, ExitStatus> {
    Ok(match expr {
        Expr::Bool(ref bool_expr) => Var::Bool(eval_boolexpr(bool_expr, functions, state)?),
        Expr::Ptr(ref ptr_expr) => Var::Ptr(eval_ptrexpr(ptr_expr, functions, state)?),
        Expr::Num(ref num_expr) => {
            let (num, size) = eval_numexpr(num_expr, functions, state)?;
            match size {
                NumSize::DWord => Var::DWord(num),
                NumSize::Word => Var::Word(num as i16),
                NumSize::Byte => Var::Byte(num as i8),
            }
        }
    })
}

/// Safely sets a variable to the given value.
fn set_variable(var: &mut Var, val: Var) {
    match (val, var) {
        (Var::DWord(val), Var::DWord(ref mut var)) => *var = val,
        (Var::Word(val), Var::Word(ref mut var)) => *var = val,
        (Var::Byte(val), Var::Byte(ref mut var)) => *var = val,
        (Var::Bool(val), Var::Bool(ref mut var)) => *var = val,
        (Var::Ptr(val), Var::Ptr(ref mut var)) => *var = val,
        _ => panic!("Mismatched variable type"),
    }
}

/// Evaluates the pointer expression and returns a reference to a variable under it.
fn deref_memory<'l>(
    ptr_expr: &PtrExpr,
    functions: &HashMap<String, Function>,
    state: &'l mut ProgramState,
) -> Result<&'l mut Var, ExitStatus> {
    let mem_location = eval_ptrexpr(ptr_expr, functions, state)?;
    state
        .memory
        .get_mut(&mem_location)
        .ok_or_else(|| ExitStatus::Fault("Segmentation fault".to_string()))
}

/// Returns a reference to a given variable.
fn get_var<'l>(var: &VarRepr, vars: &'l mut HashMap<VarRepr, Var>) -> &'l mut Var {
    vars.get_mut(var)
        .unwrap_or_else(|| panic!("Variable {} not found", var))
}

/// Runs a single statement. Returns either nothing or an exit status.
fn run_statement(
    stat: &Stat,
    functions: &HashMap<String, Function>,
    state: &mut ProgramState,
) -> Result<(), ExitStatus> {
    match stat {
        Stat::AssignVar(ref var, ref expr) => {
            let expr_val = eval_expr(expr, functions, state)?;
            set_variable(get_var(var, &mut state.vars), expr_val);
        }
        Stat::AssignPtr(ref ptr_expr, ref expr) => {
            let expr_val = eval_expr(expr, functions, state)?;
            set_variable(deref_memory(ptr_expr, functions, state)?, expr_val);
        }
        Stat::ReadIntVar(ref var) => {
            let (read_val, bytes_read) =
                i32::from_radix_10_signed_checked(&state.stdin_data[state.stdin_ptr..]);
            state.stdin_ptr += bytes_read;
            if let Some(read_val) = read_val && bytes_read > 0 {
                set_variable(get_var(var, &mut state.vars), Var::DWord(read_val));
            }
        }
        Stat::ReadIntPtr(ref ptr_expr) => {
            let (read_val, bytes_read) =
                i32::from_radix_10_signed_checked(&state.stdin_data[state.stdin_ptr..]);
            state.stdin_ptr += bytes_read;
            if let Some(read_val) = read_val && bytes_read > 0 {
                set_variable(deref_memory(ptr_expr, functions, state)?, Var::DWord(read_val));
            }
        }
        Stat::ReadCharVar(ref var) => {
            if state.stdin_ptr < state.stdin_data.len() {
                let c = state.stdin_data[state.stdin_ptr] as i8;
                state.stdin_ptr += 1;
                set_variable(get_var(var, &mut state.vars), Var::Byte(c));
            }
        }
        Stat::ReadCharPtr(ref ptr_expr) => {
            if state.stdin_ptr < state.stdin_data.len() {
                let c = state.stdin_data[state.stdin_ptr] as i8;
                state.stdin_ptr += 1;
                set_variable(deref_memory(ptr_expr, functions, state)?, Var::Byte(c));
            }
        }
        Stat::Free(ref ptr_expr, ref len_expr) => {
            let _ = eval_ptrexpr(ptr_expr, functions, state)?;
            let (_, size) = eval_numexpr(len_expr, functions, state)?;
            if size != NumSize::DWord {
                panic!("Expression size mismatch");
            }
        }
        Stat::PrintExpr(ref expr) => match expr {
            Expr::Bool(bool_expr) => {
                let bool = eval_boolexpr(bool_expr, functions, state)?;
                state.stdout += if bool { "true" } else { "false" };
            }
            Expr::Num(num_expr) => {
                let (num, _) = eval_numexpr(num_expr, functions, state)?;
                state.stdout += &format!("{}", num);
            }
            Expr::Ptr(ptr_expr) => {
                let addr = eval_ptrexpr(ptr_expr, functions, state)?;
                state.stdout += &format!("{:x}", addr);
            }
        },
        Stat::PrintChar(ref num_expr) => {
            let (num, size) = eval_numexpr(num_expr, functions, state)?;
            if size != NumSize::Byte {
                panic!("Expression size mismatch");
            }
            state.stdout.push(num as u8 as char);
        }
        Stat::PrintStr(ref ptr_expr, ref len_expr) => {
            let addr = eval_ptrexpr(ptr_expr, functions, state)?;
            let (len, size) = eval_numexpr(len_expr, functions, state)?;
            if size != NumSize::DWord {
                panic!("Invalid expression size");
            }
            for _ in 0..len {
                if let Some(Var::Byte(c)) = state.memory.get(&addr) {
                    state.stdout.push(*c as u8 as char)
                } else {
                    return Err(ExitStatus::Fault("Allocation type fault".to_string()));
                }
            }
        }
        Stat::PrintEol() => state.stdout += "\n",
    };
    Ok(())
}

/// Runs a statement graph. Returns either a value or an exit status.
fn run_graph(
    graph: &BlockGraph,
    functions: &HashMap<String, Function>,
    state: &mut ProgramState,
) -> Result<Var, ExitStatus> {
    let mut curr_block_num = 0;
    loop {
        if curr_block_num >= graph.len() {
            panic!("Block number out of bounds");
        }
        let Block(_, ref stats, ref ending) = graph[curr_block_num];
        for stat in stats {
            run_statement(stat, functions, state)?;
        }
        match ending {
            BlockEnding::CondJumps(ref conds, ref else_block_num) => {
                let mut jumped = false;
                for (cond, jump_block_num) in conds {
                    if eval_boolexpr(cond, functions, state)? {
                        curr_block_num = *jump_block_num;
                        jumped = true;
                        break;
                    }
                }
                if !jumped {
                    curr_block_num = *else_block_num;
                }
            }
            BlockEnding::Exit(expr) => {
                let (num, size) = eval_numexpr(expr, functions, state)?;
                if size != NumSize::DWord {
                    panic!("Expression size mismatch");
                }
                return Err(ExitStatus::Code(num));
            }
            BlockEnding::Return(expr) => return eval_expr(expr, functions, state),
        }
    }
}

/// Runs a single function. Returns either a value or an exit status.
fn run_function(
    name: &str,
    args: &[Var],
    functions: &HashMap<String, Function>,
    state: &mut ProgramState,
) -> Result<Var, ExitStatus> {
    let Function(ret_type, arg_vars, local_vars, graph) = functions
        .get(name)
        .unwrap_or_else(|| panic!("Function with name \"{}\" not found", name));
    if args.len() != arg_vars.len() {
        panic!("Function arguments length mismatch");
    }

    let mut old_vars = HashMap::new();
    swap(&mut state.vars, &mut old_vars);

    for (arg, (arg_type, var)) in zip(args, arg_vars) {
        match (arg, arg_type) {
            (num @ Var::DWord(_), Type::Num(NumSize::DWord)) => state.vars.insert(*var, *num),
            (num @ Var::Word(_), Type::Num(NumSize::Word)) => state.vars.insert(*var, *num),
            (num @ Var::Byte(_), Type::Num(NumSize::Byte)) => state.vars.insert(*var, *num),
            (num @ Var::Bool(_), Type::Bool) => state.vars.insert(*var, *num),
            (num @ Var::Ptr(_), Type::Ptr) => state.vars.insert(*var, *num),
            _ => panic!("Function arguments type mismatch"),
        };
    }

    for (var, var_type) in local_vars.iter() {
        match var_type {
            Type::Num(NumSize::DWord) => state.vars.insert(*var, Var::DWord(0)),
            Type::Num(NumSize::Word) => state.vars.insert(*var, Var::Word(0)),
            Type::Num(NumSize::Byte) => state.vars.insert(*var, Var::Byte(0)),
            Type::Bool => state.vars.insert(*var, Var::Bool(false)),
            Type::Ptr => state.vars.insert(*var, Var::Ptr(0)),
        };
    }

    let ret = run_graph(graph, functions, state)?;
    match (&ret, ret_type) {
        (Var::DWord(_), Type::Num(NumSize::DWord)) => {}
        (Var::Word(_), Type::Num(NumSize::Word)) => {}
        (Var::Byte(_), Type::Num(NumSize::Byte)) => {}
        (Var::Bool(_), Type::Bool) => {}
        (Var::Ptr(_), Type::Ptr) => {}
        _ => panic!("Return type mismatch"),
    }

    swap(&mut state.vars, &mut old_vars);
    Ok(ret)
}

/// Runs the entire program. Returns the stdout and the exit status (exit code or
/// fault message).
fn run(program: &Program, stdin: &[u8]) -> (String, ExitStatus) {
    let Program(functions, local_vars, graph, static_allocs) = program;
    let mut state = ProgramState {
        vars: HashMap::new(),
        memory: HashMap::new(),
        stdin_data: stdin.into(),
        stdin_ptr: 0,
        stdout: String::new(),
        malloc_addr: 0,
    };

    let mut max_addr = 0;
    let mut new_memory = HashMap::new();
    let static_allocs = match static_allocs
        .iter()
        .map(|(addr, exprs)| {
            Ok((
                addr,
                exprs
                    .iter()
                    .map(|expr| eval_expr(expr, &HashMap::new(), &mut state))
                    .collect::<Result<LinkedList<_>, _>>()?,
            ))
        })
        .collect::<Result<LinkedList<_>, _>>()
    {
        Ok(static_allocs) => static_allocs,
        Err(status) => return (state.stdout, status),
    };
    for (addr, vals) in static_allocs {
        let mut addr = *addr + 1;
        for val in vals {
            new_memory.insert(addr, val);
            addr += match val {
                Var::DWord(_) => 4,
                Var::Word(_) => 2,
                Var::Byte(_) => 1,
                Var::Bool(_) => 1,
                Var::Ptr(_) => 8,
            }
        }
        max_addr = max(max_addr, addr);
    }
    state.memory = new_memory;
    state.malloc_addr = max_addr;

    for (var, var_type) in local_vars.iter() {
        match var_type {
            Type::Num(NumSize::DWord) => state.vars.insert(*var, Var::DWord(0)),
            Type::Num(NumSize::Word) => state.vars.insert(*var, Var::Word(0)),
            Type::Num(NumSize::Byte) => state.vars.insert(*var, Var::Byte(0)),
            Type::Bool => state.vars.insert(*var, Var::Bool(false)),
            Type::Ptr => state.vars.insert(*var, Var::Ptr(0)),
        };
    }

    match run_graph(graph, functions, &mut state) {
        Err(status) => (state.stdout, status),
        Ok(_) => panic!("Return in the main function body"),
    }
}
