//! Convert the semantic errors generated by semantic analysis into errors to be
//! printed in the error system.
//!
//! As a function not returning or exiting is a syntax error, we must separate
//! the FunctionNoExitOrReturn semanticError from the others and report as a
//! syntax error

use super::{
    super::{
        ast::{BinOp, GenericId, Type, UnOp, WrapSpan},
        error::{SummaryCell, SummaryComponent, SummaryType},
    },
    semantic_errors::{self, SemanticError, StatementErrors},
};
use std::{fmt::Display, ops::Add};

/// Takes errors from semantic analysis and converts them into:
/// - A vector of erroneous (semantic) statements/definitions
/// - A vector of erroneous (syntactic) statements
pub fn convert_errors<'a>(
    def_errs: Vec<StatementErrors<'a>>,
    main_errs: Vec<StatementErrors<'a>>,
    fun_errs: Vec<(&str, Vec<StatementErrors<'a>>)>,
) -> (Vec<SummaryCell<'a>>, Vec<SummaryCell<'a>>) {
    let mut semantic_errs = Vec::new();
    let mut syntax_errs = Vec::new();

    create_cells(
        String::from("In Function Declarations"),
        def_errs,
        &mut semantic_errs,
        &mut syntax_errs,
    );
    create_cells(
        String::from("In Main Program Body"),
        main_errs,
        &mut semantic_errs,
        &mut syntax_errs,
    );
    for (fun_name, errs) in fun_errs {
        create_cells(
            format!("In Function {}", fun_name),
            errs,
            &mut semantic_errs,
            &mut syntax_errs,
        )
    }

    (semantic_errs, syntax_errs)
}

/// 
fn create_cells<'a>(
    title: String,
    statements: Vec<StatementErrors<'a>>,
    semantic_errs: &mut Vec<SummaryCell<'a>>,
    syntax_errs: &mut Vec<SummaryCell<'a>>,
) {
    for WrapSpan(span, errs) in statements {
        let (syn, sem): (Vec<SemanticError>, Vec<SemanticError>) =
            errs.into_iter().partition(|err| {
                matches!(err, SemanticError::FunctionNoReturnOrExit(_))
            });

        if !syn.is_empty() {
            let mut syntax_cell = SummaryCell::new(span);
            syntax_cell.set_title(title.clone());

            for err in syn {
                syntax_cell.add_component(err.get_component());
            }
            syntax_errs.push(syntax_cell)
        }

        if !sem.is_empty() {
            let mut semantic_cell = SummaryCell::new(span);
            semantic_cell.set_title(title.clone());

            for err in sem {
                semantic_cell.add_component(err.get_component());
            }
            semantic_errs.push(semantic_cell)
        }
    }
}

impl<'a> SemanticError<'a> {
    fn get_component(self) -> SummaryComponent<'a> {
        match self {
            SemanticError::UndefinedVariableAssignment(var_span) =>
                SummaryComponent::new(
                    SummaryType::Error,
                    201,
                    var_span,
                    format!("Assignment to undefined variable {}.", var_span)
                ),
            SemanticError::UndefinedVariableUse(var_span) =>
                SummaryComponent::new(
                    SummaryType::Error,
                    202,
                    var_span,
                    format!("Use of undeclared variable {}.", var_span)
                ),
            SemanticError::InvalidIndex(index_span, index_type) =>
                SummaryComponent::new(
                    SummaryType::Error,
                    203,
                    index_span,
                    format!("Incorrect type of index, only {} can be used to index, but here an expression of type {} was used.", Type::Int, index_type)
                ),
            SemanticError::InvalidVariableType(var_span, expected, found) =>
                SummaryComponent::new(
                    SummaryType::Error,
                    204,
                    var_span,
                    format!("Incorrect type for variable, expected a {} but found {}", expected, found)
                ),
            SemanticError::InvalidType(expr_span, expected, found) =>
                SummaryComponent::new(
                    SummaryType::Error,
                    205,
                    expr_span,
                    format!("Wrong type! Expected {} but found {}", expected, found)
                ),
            SemanticError::InvalidCallType(call_span, expected, found) =>
                SummaryComponent::new(
                    SummaryType::Error,
                    206,
                    call_span,
                    format!("Wrong type returned from call! Expected {} but found {}", expected, found)
                ),
            SemanticError::InvalidArrayLiteral(lit_span, types) =>
                SummaryComponent::new(
                    SummaryType::Error,
                    207,
                    lit_span,
                    format!("Invalid array literal, all must be the same type, but found an array with types: [{}]", types.into_iter().map(|t| format!("{}", t)).collect::<Vec<_>>().join(","))
                ),
            SemanticError::InvalidBinOp(binop_span, possible_types, possible_ops, (found_left, found_right), found_op) =>
                SummaryComponent::new(
                    SummaryType::Error,
                    208,
                    binop_span,
                    format!("Invalid application of operator {} on {} and {}. {} {}", found_left, found_right, found_op,
                        if possible_types.is_empty() {
                            format!("There are no possible input types for the operator {}.", found_op)
                        } else {
                            format!("Possible input types for {} are {}.", found_op, possible_types.into_iter().map(|(left_t, right_t)| format!("{} and {}", left_t, right_t)).collect::<Vec<_>>().join(","))
                        },
                        if possible_ops.is_empty() {
                            format!("There are no possible operators for the input types {} and {}.", found_left, found_right)
                        } else {
                            format!("Possible operators for {} and {} are {}.", found_left, found_right, possible_ops.into_iter().map(|op| format!("{}", op)).collect::<Vec<_>>().join(",") )
                        }
                    )
                ),
            SemanticError::InvalidUnOp(op_span, possible_types, possible_ops, found_type, found_op) =>
                SummaryComponent::new(
                    SummaryType::Error,
                    209,
                    op_span,
                    format!("Invalid application of {} on {}. {} {}", found_op, found_type,
                        if possible_types.is_empty() {
                            format!("There are no possible input types for {}.", found_op) // there will *always* be an input type, this is there in the event that we remove an operator from the unops table, but leave in the ast.
                        } else {
                            format!("Possible input types for {} include {}.", found_op, possible_types.into_iter().map(|t| format!("{}", t)).collect::<Vec<_>>().join(","))
                        }, if possible_ops.is_empty() {
                            format!("There are no possible unary operators for the type {}.", found_type)
                        } else {
                            format!("Possible operators on the type {} are {}.", found_type, possible_ops.into_iter().map(|op| format!("{}", op)).collect::<Vec<_>>().join(","))
                        }
                    )
                ),
            SemanticError::RepeatDefinitionVariable(var_span, orig_def_span) =>
                SummaryComponent::new(
                    SummaryType::Error,
                    210,
                    var_span,
                    format!("Repeat definition of variable {}.", var_span)
                ).set_declaration(orig_def_span),
            SemanticError::UndefinedFunction(fun_span) =>
                SummaryComponent::new(
                    SummaryType::Error,
                    211,
                    fun_span,
                    format!("Use of undefined function {}.", fun_span)
                ),
            SemanticError::RepeatDefinitionFunction(fun_span, orig_def_span) =>
                SummaryComponent::new(
                    SummaryType::Error,
                    212,
                    fun_span,
                    format!("Repeat definition of function {}.", fun_span)
                ),
            SemanticError::FunctionParametersLengthMismatch(fun_span, expected, found) =>
                SummaryComponent::new(
                    SummaryType::Error,
                    213,
                    fun_span,
                    format!("Call to function {} expects {} arguments, but {} were provided", fun_span, expected, found)
                ),
            SemanticError::FunctionArgumentTypeInvalid(arg_span, param_name, expected, found) =>
                SummaryComponent::new(
                    SummaryType::Error,
                    214,
                    arg_span,
                    format!("Function argument for parameter {} is of type {} but should have been {}.", param_name, found, expected)
                ),
            SemanticError::InvalidFunctionReturn(expr_span, expected, found) =>
                SummaryComponent::new(
                    SummaryType::Error,
                    215,
                    expr_span,
                    format!("Incorrect type returned, should have been {} but found {}.", expected, found)
                ),
            SemanticError::FunctionNoReturnOrExit(fun_name) =>
                SummaryComponent::new(
                    SummaryType::Error,
                    199,
                    fun_name,
                    format!("Function {} can potentially end without returning or exiting.", fun_name)
                ),
            SemanticError::ReadStatementMismatch(read_ident, found) =>
                SummaryComponent::new(
                    SummaryType::Error,
                    216,
                    read_ident,
                    format!("Wrong type of identifier used in read statement, found {} but should have been an {} or {}.", found, Type::Int, Type::Char)
                ),
            SemanticError::FreeStatementMismatch(expr_span, found) =>
                SummaryComponent::new(
                    SummaryType::Error,
                    217,
                    expr_span,
                    format!("Cannot free {}, needs to be a pointer types such as an {} or {}", found, Type::Pair(box Type::Any, box Type::Any), Type::Array(box Type::Any, 1))
                ),
            SemanticError::ExitStatementMismatch(expr_span, found) =>
                SummaryComponent::new(
                    SummaryType::Error,
                    218,
                    expr_span,
                    format!("Cannot exit with code of {}, must be an {}.", found, Type::Int)
                ),
            SemanticError::PrintStatementMisMatch(print_span, found) =>
                SummaryComponent::new(
                    SummaryType::Error,
                    219,
                    print_span,
                    format!("Cannot print an {}, must be of type {}.", found, Type::Any)
                ),
            SemanticError::InvalidIfCondition(cond_span, found) =>
                SummaryComponent::new(
                    SummaryType::Error,
                    220,
                    cond_span,
                    format!("If condition must be a {}, however {} was found.", Type::Bool, found)
                ),
            SemanticError::InvalidWhileCondition(cond_span, found) =>
                SummaryComponent::new(
                    SummaryType::Error,
                    220,
                    cond_span,
                    format!("While loop condition must be a {}, however {} was found.", Type::Bool, found)
                ),
            SemanticError::ReturnStatementMisplaced(stat_span) =>
                SummaryComponent::new(
                    SummaryType::Error,
                    221,
                    stat_span,
                    String::from("Cannot have a return here!")
                ),
        }
    }
}

impl Display for BinOp {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                BinOp::Add => "+",
                BinOp::Sub => "-",
                BinOp::Mul => "*",
                BinOp::Div => "/",
                BinOp::Mod => "%",
                BinOp::Gt => ">",
                BinOp::Gte => ">=",
                BinOp::Lt => "<",
                BinOp::Lte => "<=",
                BinOp::Eq => "==",
                BinOp::Ne => "!=",
                BinOp::And => "&&",
                BinOp::Or => "||",
                BinOp::Newpair => "newpair",
            }
        )
    }
}

impl Display for UnOp {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                UnOp::Neg => "!",
                UnOp::Minus => "-",
                UnOp::Len => "len",
                UnOp::Ord => "ord",
                UnOp::Chr => "chr",
                UnOp::Fst => "fst",
                UnOp::Snd => "snd",
            }
        )
    }
}

impl Display for Type {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Type::Int => write!(f, "int"),
            Type::Bool => write!(f, "bool"),
            Type::Char => write!(f, "char"),
            Type::String => write!(f, "string"),
            Type::Any => write!(f, ""),
            Type::Generic(n) => write!(f, "{}", generic_to_alpha(*n)),
            Type::Pair(box t1, box t2) => write!(f, "pair({},{})", t1, t2),
            Type::Array(box t, n) => {
                write!(f, "{}{}", t, (0..*n).map(|_| "[]").collect::<String>())
            }
        }
    }
}

fn generic_to_alpha(n: GenericId) -> String {
    let mut val = n;
    let mut result = String::new();
    loop {
        result.push((val % 26 + 65) as u8 as char);
        val /= 26;
        if val == 0 {
            break result;
        } else {
            val -= 1
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn generic_to_alpha_converts_correctly() {
        assert_eq!(generic_to_alpha(0), String::from("A"));
        assert_eq!(generic_to_alpha(1), String::from("B"));
        assert_eq!(generic_to_alpha(25), String::from("Z"));
        assert_eq!(generic_to_alpha(26), String::from("AA"));
        assert_eq!(generic_to_alpha(27), String::from("BA"));
    }
}
