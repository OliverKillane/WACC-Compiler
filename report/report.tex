\documentclass{article}
    \title{WACC}
    \author{Jordan Hall, Bartłomiej Cieślar, Panayiotis Gavriil and Oliver Killane}
    \date{14/03/22}
%===========================COMMON FORMAT & COMMANDS===========================
% This file contains commands and format to be used by every module, and is 
% included in all files.
%===============================================================================

%====================================IMPORTS====================================
\usepackage[a4paper]{geometry}
\geometry{textwidth=0.99\paperwidth, textheight=0.99\paperheight, noheadfoot, nomarginpar}
\usepackage{graphicx, amssymb, amsfonts, amsmath, tcolorbox, multirow, hyperref, xcolor, minted}
%===============================================================================

%====================================IMAGES=====================================
\graphicspath{{image/}}

% \centerimage{fraction of textwidth}{image}
\newcommand{\centerimage}[2]{\begin{center}
    \includegraphics[width=#1\textwidth]{#2}
\end{center}}
%===============================================================================

%==============================SYNTAX HIGHLIGHTING==============================
\definecolor{rustpurple}{RGB}{210,168,255}
\definecolor{rustorange}{RGB}{255,120,109}
\definecolor{rustblue}{RGB}{121,192,255}

\newcommand{\fn}[1]{\textcolor{rustpurple}{\textbf{#1}}}
\newcommand{\macro}[1]{\textcolor{rustpurple}{\textbf{#1!}}}
\newcommand{\struct}[1]{\textcolor{rustorange}{\textbf{#1}}}
\newcommand{\enum}[1]{\textcolor{rustorange}{\textbf{#1}}}
\newcommand{\module}[1]{\textcolor{rustorange}{\textbf{#1}}}
\newcommand{\trait}[1]{\textcolor{rustblue}{\textbf{#1}}}
\newcommand{\const}[1]{\textcolor{rustblue}{\textbf{#1}}}
%===============================================================================

%=================================CODE LISTINGS=================================
% \usepackage{minted}

% % write a line in rust
% % \rustline{} 
% \newcommand{\rustline}[1]{\mintinline{rust}{#1}}

% % include a wacc file from directory path
% % \waccfile{main.rs}
% \newcommand{\waccfile}[1]{\inputminted{rust}{../src/#1}}

%===============================================================================

%================================TEXT STRUCTURES================================
% Marka a word as bold
% \keyword{important word}
\newcommand{\keyword}[1]{\textbf{#1}}

% Creates a section in italics
% \question{question in italics}
\newcommand{\question}[1]{\textit{#1} \ }

% Creates a box with title for side notes.
% \sidenote{title}{contents}
\newcommand{\sidenote}[2]{\begin{tcolorbox}[title=#1]#2\end{tcolorbox}}

\newcommand{\termdef}[2]{\begin{tcolorbox}[title=Definition: #1, colframe = blue]#2\end{tcolorbox}}

\newcommand{\example}[2]{\begin{tcolorbox}[title=Example: #1, colframe = orange]#2\end{tcolorbox}}

% Creates an item in an itemize or enumerate, with a paragraph after
% \begin{itemize}
%     \bullpara{title}{contents}
% \end{itemize}
\newcommand{\bullpara}[2]{\item \textbf{#1} \ #2}

\newcommand{\gooditem}[1]{\item[\textcolor{green}{\textbullet}] \textcolor{green}{#1}}
\newcommand{\baditem}[1]{\item[\textcolor{red}{\textbullet}] \textcolor{red}{#1}}

% Creates a compact list (very small gaps between items)
% \compitem{
%     \item item 1
%     \item item 2
%     \item ...
% }
\newcommand{\compitem}[1]{\begin{itemize}\setlength\itemsep{-0.5em}#1\end{itemize}}
\newcommand{\compenum}[1]{\begin{enumerate}\setlength\itemsep{-0.5em}#1\end{enumerate}}
%===============================================================================

%==============================UNFINISHED SECTION===============================
\newcommand{\unfinished}{\begin{huge} \textcolor{red}{\textbf{UNFINISHED!!!}} \end{huge}}
%===============================================================================

\begin{document}
    \maketitle

    \section*{Compiler Design}
        \centerimage{0.9}{Compiler Map}
        Our design attempts to maximize extensibility through modularity for every stage 
        of the compiler. Each representation has has an interface and defined semantics, 
        and hence we can easily swap out translations, optimisations, entire frontends or 
        translation to architecture specific backends.
        \\
        \\ The compiler translates source code through 4 main representations; our \keyword{AST}, \keyword{IR}, \keyword{Three-Code} and \keyword{Arm-Code}.

        \subsection*{AST}
            A tree based structure using an extended structure of the \keyword{WACC grammar} 
            (allowing for more unary (fst, snd), binary operators (newpair) and types (full 
            pair types)).
            \\
            \\ Each node in the three is wrapped by a generic. This allows the \keyword{AST} to 
            be wrapped with different types of information, without having to change the structure.
            \\
            \\ Parsing of the input file (and included modules) produces an \keyword{AST} wrapped by 
            spans (pointer to the section of relevant source code). Following a successful semantic 
            analysis, the \keyword{AST} produced is wrapped by types (if one exists for a given node) 
            to allow for easier translation to our \keyword{IR}.
        
        \subsection*{IR}
            The intermediate representation consists of a basic data section (for static, immutable data),
            and functions consisting of block graphs of basic statements.
            \\
            \\ Expressions can be nested, and come in three main types; \keyword{Pointer}, \keyword{Number} 
            and \keyword{Boolean}.
            \\
            \\ The semantics of the language are also encoded here. All expressions can be reordered and 
            short-circuited (hence language semantics for short-circuiting must be encoded in its translation to IR)
            \\
            \\ This \keyword{IR} was designed to be highly general, to allow for potentially any different 
            language frontends, and as such supports full pointer arithmetic, function calls in expressions, 
            void calls, and all possible control flows (as a block graph). It can also optionally define an 
            integer overflow handler.
        
        \subsection*{ThreeCode}
            A control flow graph based \keyword{pesudo-assembly} upon which we perform all of our high-level 
            optimizations.
            \unfinished
        
        \subsection*{ArmCode}
            A control flow graph based arm representation,

    \section*{Implementation}
        % rust provides:
        % strong types, good type inference -> difficult to make mistakes
        % very strong memory safety -> important for graph & complex traversals
        % parallelization -> combined with memory safety provides compiler time guarentees
        % high performance -> allow us to do more optimisation in less time
        % support -> cargo, documentation, testing
        % 
        % Use of nightly rust for let chains, box pattern matching, etc
        %
        % Design style -> where possible functional, avoid expensive redundant copying of data, modularize.
        %
        % 
        \subsection*{Language of Choice}
        We decided to use Rust for the compiler implementation for the following reasons:
        \begin{itemize}
            \item Rust has a strong and powerful type system, which allowed us to write reliable code efficiently without worrying about null-pointer errors or type-related runtime errors.
            \item The Rust borrow checker ensured that all code we wrote would be memory-safe at compile-time without needing a garbage collector, bringing us to our next point.
            \item Parallelization of major compilation steps is trivial in Rust due to the borrow checker, which we achieved by changing \mintinline{rust}{iter()} to \mintinline{rust}{par_iter()}.
            \item Rust is extremely high-performance, which allowed us to do expensive computations (such as inlining, constant propagation, tail-call optimization, efficient register allocation, dead-code removal and same-branch analysis) quickly.
            \item Rust has many language features you would want from a modern language, such as exhaustive pattern matching, constant generics, closures and higher-order functions, first-class iterators, powerful error handling systems and a trait-based type system. These features allowed the produced code to be concise, reliable, and well-structured.
            \item Rust's development tools are mature, which gave us easy access to unit testing, benchmarking, linting, formatting, and a seamless package manager for dependencies.
        \end{itemize}
        \subsection*{Design Considerations}
        Where possible, we wrote code in a functional-style. This allowed us to have confidence that the code we wrote didn't have unexpected side effects.
        \subsection*{External Libraries}
        A small list of notable libraries we used in our implementation:
        \begin{itemize}
            \item Nom - a fast parser combinator library used in the parser.
            \item Nom-supreme - an extension to Nom that gives us error trees for better error handling.
            \item Clap - a powerful command line parser we used to pass arguments into the compiler.
            \item Rstest - a test harness extension to cargo's test harness, giving us parameterized testing.
            \item Rayon - parallelization library that gives us drop-in replacements for parallelized iterators.
        \end{itemize}
        
        
        


    \section*{Compiler Extensions}
        % full pair types
        % modules/includes
        % parallel compilation
        % function inlining
        % tail recursion optimisation
        % efficient register allocation
        % constant propagation
        % standard library
        
        We implemented a number of extensions, we will go through them and explain our implementation:
        \subsection*{Full Pair Types}
        Our compiler now supports full pair types, keeping all the semantic information about the nested types. This required a change to the parser, as our semantic analyser supported full pair types during the frontend milestone. We still allow users to write code using the old pairs and so the new feature is also backwards compatible.
        \subsection*{Modules/includes}
        The extended compiler now supports modules and includes through the following syntax:
        \begin{minted}{rust}
            mod ../tic_tac_toe_ai.wacc;
        \end{minted}
        Modules themselves can only have functions, and the syntax looks like:
        \begin{minted}{rust}
            mod ../another_include.wacc;
            begin
                int add_one(int x) is
                    return x + 1
                end
                # So on and so forth
            end
        \end{minted}
        The way we manage this is by first parsing the beginning of the main file, collecting the locations of each of these module files. We then parse each of these modules individually along with the main file. We then put the module functions into the main file's AST, to be processed as a whole by the rest of the compiler. It is also worth noting that we automatically resolve circular module imports.
        
        \subsection{Parallel Compilation}
        Our compiler performs a lot of expensive optimizations also mentioned in this list. In order to efficiently make use of the fact that most processors have multiple cores, we decided to perform all the major compilation steps in parallel. In total, we have the following steps parallelized:
        \begin{enumerate}
            \item Parsing of modules
            \item Semantic analysis.
            \item Conversion from AST to IR over functions
            \item Every optimization on Three-Code.
            \item Translation from Three-Code to the Arm Representation.
            \item 
        \end{enumerate}
        

    
    \section*{Project Management}
        % organised meetings (weekly)
        % discord server
        % tasks divided between members, each has a branch
        % CI compliance and mandatory merge request reviews (either text, or must call)
        % 
        % If we were to do again, reduce scope of project to make work more manageable.
        % Develop basic backend working from our IR, then once that works attempt to produce a graph based compiler.
        %
        % Use of CI integration and unit tests.
        % CI pushed documentation - for easy reading & catchup for current state of master.
        % 
        % More in-person -> easy help, can more easiy assist others & better idea of how tasks are progressing

    \section*{Future Improvements}
        % Compiler allows for great extensibility
        % 
        % 1. x86 Backend (can simply create translation from the three-code, all three-code optimisations will still be applied)
        % 2. Dead code removal (can be performed on the three-code, can make easy use of dataflow analysis traits & existing infrastructure)
        % 3. Split arm stack and register allocation (to allow for smaller stack frames by doing stack slot allocation in a separate pass)
        % 4. SSA (can translate from threecode -> SSA --(optimisations)--> SSA -> threecode)
        %
        % 5. General language improvements:
        %  - for loops
        %  - do while
        %  - pointer arithmetic
        %  - case statements
        %  - etc...
        % As the IR already supports all features required for these, the entire backend already supports these features, simply a case of
        % altering the AST, parser, semantic analyser and the translation to IR


\end{document}
